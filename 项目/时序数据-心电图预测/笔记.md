
# 心跳信号分类预测

## 问题描述

给定数据：

Field: 
- id: ；心跳信号分配的唯一标识
- heartbeat_signals: 心跳信号序列
- label: 心跳信号类别(0,1,2,3) 

## 评测标准

$$abs-sum=\sum_{j=1}^n \sum_{i=1}^4{|y_i-a_i|}$$


# 解法分析

## Baseline

1. 忽略数据中时序关系，将heartbeat_signals属性中每个时序值分割出来，每个时序值当做一种属性。
2. 因为heartbeat_signals的值都是[0,1]，就不选择做特殊的预处理。
3. 用LightGBM模型建模

优点：

1. 简单，快速
   
缺点

1. 性能不行

## LSTM （神经网络的baseline）

### v1版本

```
class Model(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=300, output_size=4):
        super(Model, self).__init__()
        self.hidden_layer_size = hidden_layer_size
        self.lstm = nn.LSTM(
            input_size=input_size,
            hidden_size=hidden_layer_size,
            num_layers = 2,
            batch_first=True
        )  

        self.linear = nn.Linear(hidden_layer_size, 4)

    def forward(self, input_seq):

        r_out, (h_n, h_c) = self.lstm(input_seq, None)
        x = self.linear(r_out[:,-1,:])
        return x
```

- num_layers 太多反而不太好，建议设成1
- 该版本的score 在500+

### v2版本

在v1的基础上增加网络的复杂度

- 增加一层全连接层

```
class Model(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=300, output_size=4):
        super(Model, self).__init__()
        self.hidden_layer_size = hidden_layer_size
        self.lstm = nn.LSTM(
            input_size=input_size,
            hidden_size=hidden_layer_size,
            #num_layers = 2,
            dropout=0.8,
            batch_first=True
        )  
        self.f1 = nn.Sequential(
            nn.Linear(hidden_layer_size, 64),
            nn.Dropout(0.8),
            nn.ReLU()
        )
        self.f2 = nn.Sequential(
            nn.Linear(64,output_size),
            nn.Softmax()
        )
    
    def forward(self, input_seq):
        r_out, (h_n, h_c) = self.lstm(input_seq, None)
        x = self.f1(r_out[:,-1,:])
        x = self.f2(x)
        return x
        ```

- 结果：网络很难收敛，建议去掉多余的全连接层